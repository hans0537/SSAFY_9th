arr = [3, 6, 7, 1, 5, 4]
n = len(arr) # n : 원소의 개수

# 우리는 부분집합의 개수를 구하는 공식을 알고 있다.
# 부분집합의 개수 => 2^n

'''
부분집합에 포함이 되면 1로 표시 / 포함되지 않으면 0으로 체크 => 비트연산
부분집합의 개수 => 2^n

 2^0 2^1 2^2 2^3 2^4 2^5
[ 3,  6,  7,  1,  5,  4 ]
[ 1,  0,  0,  1,  1,  0 ] => 0b011001 => 1 + 2^3 + 2^4 = 25 > 25번째 부분집합
[ 1,  0,  0,  0,  0,  0 ] => 0b000001 => 1 = 1 > 1번째 부분집합
[ 0,  0,  0,  0,  0,  0 ] => 0 = 0 > 0번째 부분집합
[ 0,  1,  0,  0,  0,  0 ] => 0b000010 = 2 > 2번째 부분집합
[ 1,  1,  0,  0,  0,  0 ] => 0b000011 = 3 > 3번째 부분집합
'''

for i in range(1 << n): # i번째 부분집합에 대해
    print(f"{i}번째 부분집합 :", end=" ")
    for j in range(n): # i번째 부분집합이 n개의 원소중에 j번째 원소를 포함하는지 검사
        if i & (1 << j): # i를 이진수로 바꿨을때 j번째 원소가 1인경우 그 j번째 원소를 포함하는 부분집합
            print(arr[j], end=", ")
    print()
print()

# 문제
# 부분집합의 합이 0이 되는 부분집합 구하기
arr = [3, -1, 7, -1, -3, 4]
n = len(arr)
for i in range(1 << n): # i번째 부분집합에 대해
    print(f"{i}번째 부분집합 :", end=" ")
    sub_set = []
    for j in range(n): # i번째 부분집합이 n개의 원소중에 j번째 원소를 포함하는지 검사
        if i & (1 << j): # i를 이진수로 바꿨을때 j번째 원소가 1인경우 그 j번째 원소를 포함하는 부분집합
            sub_set.append(arr[j])
    print(sub_set)
    if sum(sub_set) == 0:
        print("합이 0인 부분집합 :", sub_set)
print()
